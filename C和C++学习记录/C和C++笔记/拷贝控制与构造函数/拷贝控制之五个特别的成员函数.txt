一、合成的默认构造函数
	规则：
	1）如果存在类内初始值，用他们初始化。
	2）否则默认初始化。
	3）=default保留默认构造函数。
	4）构造函数无需任何实参；如果一个构造函数为所有参数都提供了默认实参，则实际上也定义了默认构造函数。
	5）只有当类没有声明任何构造函数时，编译器才会自动的生成默认构造函数。
	6）一旦定义了其他构造函数，除非再定义一个默认构造函数，否则不会有默认构造函数。
	隐患：
	1）内置类型或复合类型的成员被默认初始化行为是未定义的。
	2）含有一个其他类类型的成员，而它没有默认构造函数，此时无法默认初始化。
	使用：
	A a;//去掉空括号
	
2.先执行列表初始值初始化，没有的话默认初始化，最后构造函数体。
	如果成员是const或者引用，或者类类型的成员，而它没有默认构造函数，必须列表初始化。
3.成员初始化顺序和他们在类中的定义顺序一致，与列表中出现顺序无关。

二、拷贝构造函数
1.一个构造函数的第一个参数是自身类型的引用，其他参数都有默认值。
	Foo(const Foo&);//拷贝构造函数
2.直接初始化，通过函数匹配选择参数最匹配的构造函数来初始化
3.拷贝初始化，将右侧对象拷贝到左侧。
  拷贝初始化发生在：
  1）用=定义变量时
  2）将一个对象作为实参传递给一个非引用类型的实参
  3）从一个返回类型未非引用类型的函数返回一个对象
  4）花括号列表初始化数组成员或聚类成员
三、拷贝赋值运算符
1.Foo& operator=(const Foo&);
拷贝赋值运算符会将右侧对象非静态成员赋予左侧对象对应成员
四、对象移动
1.拷贝初始化依靠拷贝构造函数或者移动构造函数实现。
2.左值表达式表示的是一个对象的身份，而右值表达式表示的是一个对象的值。
不能将一个左值引用绑定到一个右值上，可以将一个常量左值引用或者右值引用绑定到一个右值上。
	int i=10;
	int &a=i;
	const int &aa=i*3;
	int &&r=i*3;
	int &&rr=i;//错误
3.右值只能绑定临时对象：所引用的对象将要被销毁，该对象没有其他用户
  变量可以看做只有一个运算对象的表达式
  变量表达式都是左值，这导致不能将一个右值引用绑定到一个右值引用类型的变量上
  int &&r=20;
  int &&rr=r;//错误，r是变量，是左值而rr是右值引用
4.标准move函数,utility头文件
  int &&rr=std::move(i);//将一个左值当右值使用
5.移动构造函数
  不分配新的内存，接管内存后(资源归属新对象）给定对象指针至空，移动完成;
  移动操作通常不抛出异常，必须noexcept指明。
6.移动赋值运算符
  与移动构造类似，必须noexcept指明，确保移后原对象进入一个可以析构的状态。
  当一个类没有定义任何拷贝构造函数且所有数据成员都可以移动时，编译器才会为他合成移动构造函数或者移动赋值运算符
  
  
  
  
  
  
