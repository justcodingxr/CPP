多态要求派生类公有继承基类：
只有公有继承，用户代码 才能使用派生类向基类的转换，派生类私有继承和保护继承不能使用这转换
（用户代码：外部函数指一些通过对象，对象指针，其他类的成员函数以及全局域的函数等等的方式访问，
可以将对象和外部函数理解为用户代码，以区别类和类成员。）

1.无论什么继承方式，派生类和派生类的成员都可以使用派生类到基类的转换，（但是多态性，派生类要公有继承，多态性为用户代码使用才有意义。
2.只有公有继承，用户代码才能使用派生类向基类的转换，派生类私有继承和保护继承用户代码不能使用这转换
3.基类A，派生类B的派生类C和派生类B的派生类C的成员：
	如果派生类B公有继承A或者保护继承A，他们可以使用派生类B向A的转换
	如果派生类B私有继承A，派生类B的派生类C和派生类B的派生类C的成员，他不们可以使用派生类B向A的转换
class成员访问权限默认私有，继承方式默认私有
struct成员访问权限默认公有，继承方式默认公有
所以class要发挥多态性，派生类要显示公有继承

一般：
基类引指针用传基类对象，访问基类成员；派生类引指针用传派生类对象，访问派生类成员；
多态希望：
基类对象赋予基类引用或指针，可以访问基类成员；	派生类对象赋予基类引用和指针，可以访问派生类自己定义的成员，和自己重定义的同名同参函数成员；
实际上情况是：
基类对象赋予基类引用或指针，可以访问基类成员；	派生类对象赋予基类引用和指针，可以访问派生类的自己定义的那部分不同成员以及同名同参的确是继承自基类的成员；（同名是因为公有继承的话，必然同名；）
（自己定义的那部分会造成同名不同参的情况，放在不重载和同名隐藏讨论）

怎么实现多态：
1.利用基类引用或指针接收派生类对象，同时2.重定义的成员定义为虚函数的形式实现动态绑定；这样基类对象赋予基类引用或指针，可以访问基类成员；派生类对象赋予基类引用和指针，可以访问派生类的自己定义的那部分不同成员以及同名的重定义虚函数成员。

多态性实现：
1.类型相容不必一致的形式+自动转换
派生类类型对象 为基类对象赋值；
或者派生类对象 赋予 基类类型引用；
或 派生类类型对象 地址 可以赋予 基类类型指针；
但只有基类的引用和指针才有派生类向基类的自动类型转换，这是前提；
（相容，但是不能实现基类调用函数实现多态，因为派生类对象给基类对象 赋值时，基类对象调用构造函数，只是完成了基类部分的成员 赋值；所以相容形式的只有后面两个符合）
（通常对象赋予指针或者用于要类型一致，但是派生类对象或对象地址赋予父类引用和指针却是一个重要例外，
这是基于他们虽然类型不一样但是有相同的基类部分；反过来，基类却不能向子类隐式转换，因为基类并没有派生类中不相同的那部分，多了可以去除，少了就不行；
当然派生类向基类转换也可能因为访问权限问题不能实现）
2.同名函数定义为虚函数实现动态绑定
静态绑定：使用基类引用  或指针调用同名普通函数，仍然调用的是基类函数，这在运行前就已经被决定了；
要实现多态：需要虚函数，实现动态绑定，运行时决定调用的是基类还是派生类同名虚函数，动态绑定后，使用基类的指针或引用调用虚函数（@）才能实现多态，
只有基类的引用和指针才有派生类向基类的自动类型转换，若使用基类对象，仍然不能实现多态，这是最后使用要求。
@不是因为只能调用虚函数，而是因为调用虚函数运行时的不同选择体现了多态性；
@如果派生类只是继承了基类（有虚函数的），并没有将同名虚函数写出来，那么使用基类的指针或引用调用虚函数显然调用的是基类的，只是继承了，毕竟都没有覆盖完成。
@如果派生类只是继承了基类（没有虚函数），派生类有虚函数，那么使用基类的指针或引用调用虚函数显然是错误的，基类没有派生类的虚函数。
（被继承后虚函数自动就还是虚函数，不用写明virtual，这是第二步。）
3.动态绑定底层
可以将派生类对象分为多部份，占据多个地址，基类指针或引用就是通过派生类对象继承的基类的那部分实现的绑定，指针引用被赋予的地址就是那部分的地址。

派生类向基类的转换的使用：
1.无论什么继承方式，派生类和派生类的成员都可以使用派生类到基类的转换（但是多态性，派生类要公有继承，多态性为用户代码使用才有意义。）
2.只有公有继承，用户代码才能使用派生类向基类的转换，派生类私有继承和保护继承用户代码不能使用这转换
3.基类A，派生类B的派生类C和派生类B的派生类C的成员：
	如果派生类B公有继承A或者保护继承A，他们可以使用派生类B向A的转换
	如果派生类B私有继承A，派生类B的派生类C和派生类B的派生类C的成员，他不们可以使用派生类B向A的转换
	
继承中类的作用域
派生类作用域是嵌套在基类作用域中的，所以我们才可以象使用自己的成员一样使用基类成员。

不可重载与同名隐藏
同名隐藏因为名字检查优先于参数类型，可以使用作用域来使用同名隐藏的成员。使用作用域可以颠覆查找规则，违背同名隐藏。
考虑这样的情况：派生类继承了一个同名但是形参列表不同的函数（这说明不是虚函数，虚函数都是同名同参数列表的），
这时派生类调用同名函数，传参列表和基类一样，和派生类不一样，不会发生重载，而是因为同名成员隐藏，
发生错误，派生类有同名函数却不能用，而基类同名函数又不可见，这可以用作用域来调用。
这也就是为什么虚函数要用相同的名字和参数列表类型，不一样的话无法通过指针或引用调用派生类虚函数。


class Base{
	public:
		virtual int fcn();
}

class D1:public Base{//并没有覆盖基类的虚函数virtual int fcn();
	public:
		int fcn(int);//virtual int fcn();同名不同参
		virtual void f2();
};

class D2:public D1{
	public:
		int fcn(int);
		int fcn();//virtual不用写，虚函数覆盖了
		void f2();
}

Base b; D1 d1; D2 d2;
Base *p1=&b, *p2=&d1, *p3=&d2;
p1->fcn();          //运行时调用Base::virtual int fcn()
p2->fcn();			//没有覆盖虚函数，运行时调用Base::virtual int fcn()
p3->fcn();          //覆盖虚函数,运行时调用D2::virtual int fcn()

D1 *q1=&d1; D2 *q2=&d2;
p2->f2();          //错误，Base没有f2()成员，多态用在
q1->f2();          //运行时调用D1::virtual void f2()
q2->f2();          //运行时调用D2::virtual void f2()
