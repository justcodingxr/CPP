运算符重载
	当运算符作用于类类型的对象时。
	一元：左侧对象绑定到this
	二元：左对象传入第一个参数，右对象传入第二个
		operator+（A &a,B &b){
			//定义
			return CLASS c;
		}
	运算
		a+b；或者operator+（a,b);
	成员和非成员的选择：
		赋值（=），下标（[]),调用（（）），成员访问->一般定义为成员；
		递增递减，解引用一般是成员；
		具有对称性的算数，相等性，关系性，位运算一般普通非成员函数，而且一般不需要改变
		运算对象的状态，所以形参都是常量的引用，会得到一个新值有别于左右两个运算对象，
		新值常在一个局部变量中，最后将它的副本返回作为结果。

下标运算符通常有常量和非常量两个成员函数：
	T& operator[](size_t/int n){
		return elements[n];
	}
	const T& operator[](size_t/int n){
		return elemments[n];
	}
	
递增递减运算符
	迭代器类
		递增递减运算符让类在元素序列移动，改变的就是操作对象的状态，最好定义为成员函数
	内置类型
		前置后置两个版本:
			前置递增递减:返回的状态随对象同时更新，是一个。
				T & operator++(){
					check(curr,"越界“）；//检查边界
					++curr;//移动
					return *this;
				}
				T &operator--（）{
					--curr;//curr为0,则继续递减至无效下标
					check(curr,"越界");
					return *this;
					}
				
			后置递增递减:返回的状态不变，对象更新了，int参数为了显示调用。
				T & operator++(int){
					T t=*this;//保留状态，以便返回
					++*this;//对象更新
					return t;//原来的对象
				}
				T &operator--（）{
					T t=*this;
					--*this;//curr为0,则继续递减至无效下标
					return t;
				}	
			调用：p.operator++(0);显示调用后置递增
				  p.operator++();调用前置递增

箭头重载运算符的特殊
	对箭头运算符的重载不能改变箭头获取成员的事实；
	所以它的返回值只能是指向类的对象的指针或一个重载的箭头运算符的对象。
	
函数调用运算符()
	像使用函数一样使用该类的对象；
	int operator()(int val){
		return val+10;
	}
	A a；int k=a.(2);//通过像函数一样对象（）中传参调用重载函数
	a就是函数对象；函数对象中通常有一些数据成员，这些成员被用于定制调用运算符中的操作；
	也就是说成员数据常做调用重载运算的参数；
			
			
lambda是函数对象
	编译器为lambda表达式产生一个类，类中有调用运算符；
	默认情况，lambda不改变捕获的变量，因此它对应的类的调用运算符是const 成员函数。	
	
	lambda产生的类不含有默认构造函数，赋值运算符，默认析构函数，
	是否有拷贝/移动构造函数 视捕获的数据成员类型决定（不是视参数列表决定），相应的使用函数对象时参数也取决于它；		
	
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
		
		